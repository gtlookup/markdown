kernel（内核）特征：并发、共享、虚拟、异步。

- 把CPU抽象成进程
- 把磁盘抽象成磁盘
- 所内存抽象成地址空间

界面属于外壳（shell），而不是kernel（内核）

# 操作系统启动

DISK：存放OS

BIOS：基本I/O处理系统

- 将Bootloader从磁盘的引导扇区（512字节）加载到0x7c00
- 跳转到 CS(段寄存器):IP(指令寄存器) = 0xf000:fff0

Bootloader：加载OS

- 将操作系统的代码和数据从硬盘加载到内存
- 跳转到操作系统的起始地址

POST（加电自检）：寻找显卡和执行BIOS

# 与设备和程序交互

面向外设是通过中断和IO进行处理的，面向应用程序是通过系统调用和异常提供的相应功能

系统调用：

- 来源：应用程序
- 应用程序主动向操作系统发出服务请求
- 处理时间：异步或同步
- 响应：等待或持续

异常：

- 来源：不良的应用程序
- 非法指令或者其它坏的处理状态(如：内存出错)
- 处理时间：同步
- 响应：杀死或重新执行异常程序指令

中断：

- 来源：外设（键盘、鼠标、声卡、显示等）
- 来自不同的硬件设备的计时器和网络中断
- 处理时间：异步
- 响应：持续，用户的应用程序无感知

应用程序不可以直接访问外设，需要调用操作系统操作来间接访问外设；操作系统封装了底层与外设交互的接口，这样应用程序就不需要提供对外设的驱动了

> 硬件中断

设置中断标记（CPU初始化）

1. 将内部、外部事件设置中断标记
2. 中断事件ID

> 软件中断

1）保存当前处理状态

2）中断服务程序处理

3）清除中断标记

4）恢复之前保存的处理状态

> 异常中断

1）保存现场

2）异常处理

- 杀死产生了异常的程序
- 重新执行异常指令

3）恢复现场

> 跨越操作系统边界的开销

在执行时间上的开销超过程序调用

开销：

- 建立中断/异常/系统调用号与对应服务例程映射关系的初始化开销
- 建立内核堆栈
- 验证参数
- 内核态映射到用户态的地址空间更新页面映射权限
- 内核态独立地址空间

# 内存

## 地址空间

物理地址空间：硬件支持的地址空间。起始地址0，到地址MAX（系统）

逻辑地址空间：一个运行的程序所拥有的内存范围。起始地址0，到地址MAX（程序）

逻辑地址空间生成：编译C程序到汇编



https://blog.csdn.net/iwanderu/article/details/103934127



https://www.bilibili.com/video/BV1uW411f72n?p=14&vd_source=2ddb3806f7e4c08fd841529f280d8bee

