# 1，二叉查找树

- 左子树比自己小，右子树比自己大

- 左右子树也都满足上面条件（左小右大）
- 查找最大值：从根结点往右子树查，最小往左查

- 中序查找：从左侧最小值开始，向右查找，结果为升序排列的值，也能确定了最大和最小值
- 删除：被删除结点的后继结点取代自己
  - 后继结点：自己右子树中最小的



# 2，AVL 树

- 具有二叉查找树的全部特性
- 每个结点的左子树和右子树的高度至多等于1
- 保证大量结点不会偏向一边
- 缺点：太严格，跑程序太耗性能



# 3，红黑树

- 每个结点非黑即红
- 根结点是黑色
- 每个红色结点的子结点都是黑色
- 不管哪个结点，到叶子结点所经过的黑色结点数量是一样的
- 当一个结点有黑色子结点，那么它肯定有两个子结点

## 3.1 三种操作

> 旋转结点=ROOT，左子结点=L，右子结点=R，父结点=parent

- 左旋：右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点
  - ROOT.parent = R，ROOT.R = R.L
- 右旋：左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点
  - ROOT.parent = L，ROOT.L = L.R
- 变色：由红变黑或由黑变红

## 3.2 插入

- 查找要插入的位置
- 插入后自平衡
- 插入的结点==必须红色==

### 3.2.1 插入情景

- 在空树里插入：插入后设黑
- 插入的key存在：将值赋给已存在的结点
- 父结点是黑：直接插入
- 父结点是红
  - 叔结点红，爷结点肯定黑
    - 将父和叔结点设黑
    - 将爷结点设红
    - 将爷结点作为当前结点做后续处理
  - 叔结点不存在或为黑，且父结点是爷结点的**左子结点**
    - 是父的左子场合==（LL双红）==
      - 父设黑，爷设红
      - 对爷右旋
    - 是你的右子场合==（LR双红）==
      - 对父左旋
      - 设父为当前结点，得到**LL双红**情况，进行**LL双红**处理
  - 叔结点不存在或为黑，且父结点是爷结点的**右子结点**
    - 是父的右子场合==（RR双红）==
      - 将父设黑，爷设红
      - 对爷左旋
    - 是父的左子场合==（RL双红）==
      - 对父右旋
      - 设父为当前结点，得到**RR双红**情况，进行**RR双红**处理



